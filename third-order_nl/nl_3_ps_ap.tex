


Boolean functions used in cryptosystems should have high higher-order nonlinearity to resist several known attacks,
such as algebraic attack and low-degree approximation. The higher-order nonlinearity also plays an important role in coding theory and theoretical computer science. It is well-known that bent functions have the highest nonlinearity in even number of variables and thus they possess
the best resistance against fast correlation attack and best affine approximation. However, there is limited knowledge regarding the higher-order nonlinearity of bent functions because computing the higher-order nonlinearity, or even providing tight lower bounds, is a hard task.
In 1974, Dillon proposed two well-known classes of bent functions based on partial spread (in brief, $\mathcal{PS}$), called $\mathcal{PS}^-$ and $\mathcal{PS}^+$, respectively. He also exhibited a subclass of  $\mathcal{PS}^-$, known as partial spread affine plane ($\mathcal{PS}_{ap}$ for short). In this paper, we provide a lower bound on the third-order nonlinearity of the simplest $\mathcal{PS}_{ap}$ bent functions in $n$ variables, where $n\ge 6$ is even, by calculating nonlinearities of all second-order derivatives of this kind of bent functions.
Compared to the two known lower bounds on the third-order nonlinearity given by Carlet and Tang et al. respectively,
our lower bound is much better than these two ones.


















































% for i in [1..2^5] do
%     inputvector:=Intseq(i-1,2,n);
%     eltvector:=&+[inputvector[j]*v^(j-1):j in [1..n]];
%     Append(~input,(eltvector));
% end for;

% for i in [1..2^n] do
%     inputvector:=Intseq(sbox[i],2,n);
%     eltvector:=&+[inputvector[j]*v^(j-1):j in [1..n]];
%     Append(~output,(eltvector));
% end for;

% function newsbox(x)
%     if x eq 0 then
%         return 0;
%     end if;
%     for i in [1..1024] do
%         if x eq input[i] then
%             return output[i];
%         end if;
%     end for;
% end function;



% G:=OrthoTest(newsbox,n);
% ddtG:=DDTexe(G,n);



%   \begin{tikzpicture}[
%     node distance = 5ex,
%     scale = 3,
%     thick,
%     > = latex,
%     % change the
%     z = {(0.35, -0.4)},
%     edge/.style = {draw, thick, -, black},
%     sinal/.style = {inner sep = 1pt, thin, opacity = 0.4,
%       fill = blue, circle, text opacity = 1},
%     mtx/.style = {
%   %     matrix of math nodes,
%       matrix of nodes,
%       every node/.style = {
%         anchor = base,
%         text width = 2em,
%         text height = 1em,
%         align = center,
%       }
%     },
%     ]

%     \def\dist{0.1}
%     \def\cube{
%         % Vertices. (A,B,C), A x轴  B z轴  C y轴


%         % \node[left] (v0) at (0,0,0) {$ A $};
%         % note that command above can construct nodes and label them at the same time,
%         % but sometimes you don't need the text,
%         % so I just construct the coordinates and then label coordinates
%         \coordinate (v0) at (0, 0, 0)  ;
%         \coordinate (v1) at (0, 1, 0)  ;
%         \coordinate (v2) at (1, 0, 0)  ;
%         \coordinate (v3) at (1, 1, 0)  ;
%         \coordinate (v4) at (0, 0, 1)  ;
%         \coordinate (v5) at (0, 1, 1)  ;
%         \coordinate (v6) at (1, 0, 1)  ;
%         \coordinate (v7) at (1, 1, 1)  ;
%         \coordinate (v8) at (0, 2, 0)  ;
%         \coordinate (v9) at (1, 2, 0)  ;
%         \coordinate (v10) at (0, 2, 1) ;
%         \coordinate (v11) at (1, 2, 1) ;
%     }
%     \begin{scope}[opacity=1] % opacity is the transparent
%         \cube{};
%         % labeling verticals with text A B C at left\right\below\above\below left\below right\above left\above right
%         \node[left] at (v0) {$ A $};
%         \node[left] at (v1) {$ B $};
%         \node[right] at (v2) {$ C $};
%         \node[above right] at (v3) {$ D $};
%         \node[left] at (v4) {$ E $};
%         \node[below left] at (v5) {$ F $};
%         \node[right] at (v6) {$ G $};
%         \node[right] at (v7) {$ H $};
%         \node[left] at (v8) {$ I $};
%         \node[above right] at (v9) {$ J $};
%         \node[below left] at (v10) {$ K $};
%         \node[right] at (v11) {$ L $};
%         % Edges with some differential: alpha gamma beta theta
%         % arrow with direction from v1 to v0

%         \draw[->] (v2) -- (v3);
%         \draw[->] (v3) -- (v9);
%         \draw[->] (v6) -- (v7);
%         \draw[->] (v7) -- (v11);
%         % dotted line from v1 to v2 and the middle of line labeled is gamma
%         \draw[dashed] (v0) -- node[fill = white] {$ \gamma $} (v2) ;
%         \draw[dashed] (v4) -- node[fill = white] {$ \gamma $} (v6);
%         \draw[dashed] (v1) -- node[fill = white] {$ \beta $} (v5) -- node[fill = white] {$ \theta $} (v7) -- node[fill = white] {$ \beta $}(v3) -- node[fill = white] {$ \theta $} (v1);
%         \draw[dashed] (v8) -- node[fill = white] {$ \alpha $}(v10);
%         \draw[dashed] (v11) -- node[fill = white] {$ \alpha $}(v9);
%     \end{scope}

%     \begin{scope}[opacity=0.2]
%         % the pics in this part are transparent 0.2,
%         % if not want this condition, delete the commands.
%         \draw[<-] (v0) -- (v1);
%         \draw[<-] (v1) -- (v8);
%         \draw[<-] (v4) -- (v5);
%         \draw[<-] (v5) -- (v10);
%     \end{scope}

%         % \foreach \i in {0, 1, ..., 11}{ \draw[fill = black] (v\i) circle (0.1pt); }
%         % } % boomerang attack model

%         \begin{scope}[]
%             %
%             \coordinate (E0)  at (2, 0-0.4, 0);
%             \coordinate (E0L) at (2-0.3, 0-0.4, 0);
%             \coordinate (E0R) at (2+0.15, 0-0.4, 0);
%             \coordinate (E1)  at (2, 1-0.4, 0);
%             \coordinate (E1L) at (2-0.3, 1-0.4, 0);
%             \coordinate (E1R) at (2+0.15, 1-0.4, 0);
%             \coordinate (E2)  at (2, 2-0.4, 0);
%             \coordinate (E2L) at (2-0.3, 2-0.4, 0);
%             \coordinate (E2R) at (2+0.15, 2-0.4, 0);
%             \draw[->] (E0) -- node[right] {$ E_1^{-1} $} (E1);
%             \draw[->] (E2) -- node[right] {$ E_0 $} (E1);
%             % dotted line with transparent
%             \draw[dashed,opacity=.5] (E0R) -- (E0) -- (E0L);
%             \draw[dashed,opacity=.5] (E1R) -- (E1) -- (E1L);
%             \draw[dashed,opacity=.5] (E2R) -- (E2) -- (E2L);
%         % \foreach \i in {0, 1, ..., 11}{
%         %   \node at (v\i) {\i};
%         % }
%       \end{scope}

%     \end{tikzpicture}%

F<v>:=GF(2,8);
G:=[x:x in F|x^8 + x^4 + x^3 + x^2 + 1 eq 0];
for g in G do
    g:=v;
    // sbox=[0, 152, 136, 56, 65, 217, 149, 189, 142, 95, 147, 214, 10, 103, 171, 213, 185, 4, 3, 20, 93, 54, 199, 202, 198, 116, 227, 33, 124, 181, 56, 196, 106, 5, 53, 40, 169, 194, 117, 56, 58, 122, 82, 103, 60, 9, 178, 182, 111, 194, 132, 67, 83, 248, 191, 27, 228, 122, 186, 157, 232, 61, 96, 24, 26, 6, 145, 122, 45, 76, 121, 25, 204, 64, 58, 52, 142, 177, 11, 37, 254, 244, 188, 143, 2, 206, 39, 59, 105, 140, 48, 101, 28, 161, 241, 228, 182, 193, 124, 211, 65, 13, 0, 116, 55, 254, 4, 9, 218, 12, 100, 24, 233, 116, 140, 54, 224, 53, 158, 51, 153, 73, 222, 88, 22, 68, 45, 182, 165, 33, 134, 12, 150, 118, 162, 210, 49, 123, 233, 9, 154, 56, 207, 176, 203, 54, 164, 210, 218, 159, 66, 222, 89, 139, 220, 22, 143, 187, 37, 83, 142, 112, 152, 202, 179, 251, 33, 15, 114, 126, 132, 163, 158, 222, 216, 110, 245, 153, 76, 173, 197, 226, 232, 254, 45, 109, 110, 55, 247, 95, 56, 107, 7, 102, 152, 14, 29, 231, 100, 169, 255, 145, 63, 22, 236, 121, 200, 154, 38, 237, 17, 76, 223, 46, 7, 92, 60, 6, 110, 38, 222, 149, 45, 69, 32, 242, 189, 200, 151, 193, 38, 176, 195, 88, 100, 204, 28, 232, 181, 193, 66, 146, 67, 137, 8, 86, 47, 216, 111, 218, 174, 6, 172, 113, 104, 103 ];

    nonlinearity v:=v^24
    f:=func<x|x^3 + g^60*x^5 + g^191*x^6 + g^198*x^9 + g^232*x^10 + g^120*x^12+ g^54*x^17 + g^64*x^18 + g^159*x^20 + g^144*x^24 + g^248*x^33+ g^203*x^34 + g^32*x^36 + g^18*x^40 + g^216*x^48 + g^78*x^65+g^46*x^66 + g^91*x^68 + g^27*x^72 + g^70*x^80 + g^52*x^96+ g^224*x^129 + g^18*x^130 + g^197*x^136 + g^253*x^144 + x^160>;
    for b in F do
        if b eq 0 then continue; end if;
        Walsh_spectra:=[];
        for a in F do
            Append(~Walsh_spectra,Abs(&+[(-1)^(Integers()!Trace(b*f(x)+a*x)):x in F]));
        end for;
        Set(Walsh_spectra);
        //if Max(Walsh_spectra) eq 128 then
        //    print "b=",b;
        //end if;
    end for;
end for;

F<v>:=GF(2,8);
g:=v;
for i in [10..255] do
    i:=24;
    f:=func<x|Trace(v^i*(x^3 + g^60*x^5 + g^191*x^6 + g^198*x^9 + g^232*x^10 + g^120*x^12+ g^54*x^17 + g^64*x^18 + g^159*x^20 + g^144*x^24 + g^248*x^33+ g^203*x^34 + g^32*x^36 + g^18*x^40 + g^216*x^48 + g^78*x^65+g^46*x^66 + g^91*x^68 + g^27*x^72 + g^70*x^80 + g^52*x^96+ g^224*x^129 + g^18*x^130 + g^197*x^136 + g^253*x^144 + x^160))>;
    if Max([&+[(-1)^(Integers()!(f(x)+Trace(a*x))):x in F]:a in F]) eq 128 then
    wf:=[&+[(-1)^(Integers()!(f(x)+Trace(a*x))):x in F]:a in F];
    i;
    end if;
end for;

subspace_set:={};
for a,b in GF(2,4) do
    if a eq b then continue; end if;
    flag:=0;
    for x in F do
        if f(x)+f(x+a)+f(x+b)+f(x+a+b) ne 0 then
            flag:=1;
            break;
        end if;
    end for;
    if flag eq 1 then
        print "not a subspace";
        break;
    end if;
end for;




% for g=v, we have b=v^24 s.t. bf is an affine function.
======================================================================================

diff_spec:=[
    [ 0, 2, 6, 595386, 416361, 35805 ],
    [ 0, 2, 4, 6, 8, 12, 713031, 211761, 92070, 15345, 5115, 10230 ],
    [ 0, 2, 4, 6, 8, 629331, 330336, 72540, 13020, 2325 ],
    [ 0, 2, 4, 6, 8, 628401, 329871, 75330, 12555, 1395 ],
    [ 0, 2, 4, 6, 8, 10, 633636, 322701, 75045, 13980, 1905, 285 ],
    [ 0, 2, 4, 6, 8, 10, 12, 630216, 327081, 76215, 12150, 1665, 195, 30 ],
    [ 0, 2, 4, 6, 8, 10, 635314, 317626, 80290, 11780, 2480, 62 ],
    [ 0, 2, 4, 6, 8, 10, 631811, 322617, 80197, 11098, 1674, 155 ],
    [ 0, 2, 4, 6, 8, 10, 633733, 320695, 78399, 12803, 1736, 186 ],
    [ 0, 2, 4, 6, 8, 10, 641514, 307706, 81375, 14880, 1705, 372 ],
    [ 0, 2, 4, 6, 8, 10, 634260, 321036, 76353, 13857, 1767, 279 ],
    [ 0, 2, 4, 6, 8, 10, 12, 14, 630664, 324942, 78647, 11842, 1364, 31, 31, 31 ],
    [ 0, 2, 4, 6, 8, 22, 636306, 315018, 82335, 11715, 2145, 33 ],
    [ 0, 2, 4, 6, 8, 637701, 313131, 80910, 14415, 1395 ],
    [ 0, 2, 4, 6, 8, 626541, 330336, 79515, 10230, 930 ],
    [ 0, 2, 4, 6, 8, 10, 634291, 318401, 81995, 10385, 2170, 310 ],
    [ 0, 2, 4, 6, 8, 640491, 304296, 89280, 13020, 465 ],
    [ 0, 2, 4, 6, 8, 10, 12, 632431, 322958, 77562, 13020, 1333, 186, 62 ],
    [ 0, 2, 4, 6, 8, 624216, 334986, 76725, 11160, 465 ],
    [ 0, 2, 4, 6, 8, 10, 639045, 311861, 80410, 13860, 2365, 11 ]
];

=====================================================================================
// we want to find 10 bit quadratic APN, and test whether they are ccz-eq to some APN classes or instances
// f(x)=x^d+x^i+beta*x^j is a trinomial, it ccz eq to x^d +alpha*x^i+beta*x^j, so we confirm that no new APN instance for trinomial.
// d = 5,6,9,10,12,17,33,34,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264, 272, 288, 320, 384, 513, 514, 516, 520, 528, 544, 576, 640, 768 no APN instance

// test x^d + x^i + beta x^j, exclude the case of EA s.t. L2 . F . L1
n:=10;
Z:=Integers();
F<v>:=GF(2,n);
F5<w>:=GF(2,n div 2);
Fstar:=[v^i:i in [0..2^n-2]];
P<x>:=PolynomialRing(F);
index_wt_2:={2^i+2^j:i,j in [0..n-1]|i ne j};

load "DiffSpecOdExe.m";
for d in D do
    for i,j in index_wt_2 do
        if i eq d or j eq d or i eq j then continue; end if;
        //exclude the case of L2=a x^2i + b x^2j + x and F = x^3
        if i in {2^k*3:k in [0..n-1]} and j in {2^k*3:k in [0..n-1]} then continue; end if;
        if i in {2^k*3^2:k in [0..n-1]} and j in {2^k*3^2:k in [0..n-1]} then continue; end if;
        ccz_coef_set:={};
        i,j;
        for beta in Fstar do
            if #{x^(2^i):x in ccz_coef_set,i in [1..n-1]} eq 2^n-1 then break; end if;
            // exclude the case of L2=2^{n-i},L1=2^i
            if beta in {x^(2^i):x in ccz_coef_set,i in [1..n-1]} then continue; end if;
            f:=x^d+x^i+beta*x^j;
            if IsAPN(f) eq true then
                print "f is APN and parameters [i,j,beta] are:";
                i,j,beta;
                ddtS:=DiffSpecOd(func<x|x^d+x^i+beta*x^j>,n);
                ddtS;
                if ddtS notin diff_spec then
                    print "new diff_spec_od,i=",i;
                    Write("APN_10bit_new_instance.txt",[i,j]);
                    Write("APN_10bit_new_instance.txt",beta);
                else
                    print "existing instance!";
                    // exclude the case of L2=a^d x,L1=x/a
                    Include(~ccz_coef_set,beta);
                end if;
            else
                //print "not APN";
                Include(~ccz_coef_set,beta);
            end if;
        end for;
    end for;
end for;


//another f(x) is a quadrinomial, f = x^9 + a*Tr_2^n(b*x^i)

n:=10;
d:=9;
Z:=Integers();
F<v>:=GF(2,n);
Fstar:=[v^i:i in [0..2^n-2]];
P<x>:=PolynomialRing(F);
index_wt_2:={2^i+2^j:i,j in [0..n-1]|i ne j};

for i in index_wt_2 do
    if i in [2^j*d:j in [0..n-1]] then continue; end if;
    i;
    ccz_coef_set:={};
    for beta in Fstar do
        if #{x^(2^i):x in ccz_coef_set,i in [1..n-1]} eq 2^n-1 then break; end if;
        // exclude the case of L2=2^{n-i},L1=2^i
        if beta in {x^(2^i):x in ccz_coef_set,i in [1..n-1]} then continue; end if;
        f:=func<x|x^d+ v^2*(&+[(beta*x^i)^((2^2)^(j-1)):j in [1..n div 2]])>;
        if IsAPN(f,n) eq true then
            print "f is APN and parameters [i,j,beta] are:";
            i,beta;
            ddtS:=DiffSpecOd(f,n);
            ddtS;
            if ddtS notin diff_spec then
                print "new diff_spec_od,i=",i,"beta=",beta;
                Write("APN_10bit_new_instance.txt",i);
                Write("APN_10bit_new_instance.txt",beta);
            else
                print "existing instance!";
                // exclude the case of L2=a^d x,L1=x/a
                Include(~ccz_coef_set,beta);
            end if;
        else
            //print "not APN";
            Include(~ccz_coef_set,beta);
        end if;
    end for;
end for;



=====================================================================================



function Sbox2ff(inputsbox)
    Z:=Integers();
    n:=Ilog2(#inputsbox);
    F<v>:=GF(2,n);
    list:=[];
    for i in [0..2^n-2] do
        Append(~list,&+[Intseq(inputsbox[&+[Z!Eltseq(v^i)[j]*2^(j-1):j in [1..n]]+1],2,n)[k]*v^(k-1):k in [1..n]]);
    end for;
    Append(~list,F!0);
    function ff_fromsbox(x)
        return (x eq 0) select F!0 else list[Log(x)+1];
    end function;
    return ff_fromsbox;
end function;


======================================================================================

function IsAPN(f,variables)
    n:=variables;
    F<al>:=GF(2,n);
    for i in [0..2^n-2] do
        a:=al^i;
        set_b:={}; set_a:={};
        for y in F do
            if not y in set_a then
                b:=f(y+a)-f(y);
                if b notin set_b then
                    Include(~set_b,b);
                else
                    return false;
                end if;
                Include(~set_a,y+a);
            end if;
        end for;
    end for;
    return true;
end function;


function IsAPN(f)
    P:=Parent(f);
    F<al>:=BaseRing(P);
    n:=Degree(F);
    for i in [0..2^n-2] do
    a:=al^i;
    set_b:={}; set_a:={};
    for y in F do if not y in set_a then
    b:=Evaluate(f,y+a)-Evaluate(f,y);
    if b notin set_b then Include(~set_b,b);
    else
    return false; end if;
    Include(~set_a,y+a); end if;
    end for; end for;
    return true;
end function;


Z:=Integers();
F<v>:=GF(2,8);
[&+[Z!Eltseq(x)[i]*2^(i-1):i in [1..8]]:x in F]; 